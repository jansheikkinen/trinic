# Grammar
# A grammar specification of the TriniC language using Extended Backus-Naur Form

program = declaration ;

declaration = structdecl | funcdecl | vardecl ;
structdecl  = structtype idargs "end" ; # idk if idargs is right
funcdecl    = "function" IDENTIFIER "(" (idargs | "void") ")" "->" type
              statement* "end" ;

# TODO: enums, unions, tagged unions(???)
basetype    = "int8"   | "int16"   | "int32"   | "int64"   | "isize"
            | "uint8"  | "uint16"  | "uint32"  | "uint64"  | "usize"
            | "float8" | "float16" | "float32" | "float64" | "fsize"
            | "byte"   | "char"    | "void"    | "bool" ;
arraytype   = type "[" expression "]" ;
pointertype = type "*" ;
structtype  = "struct" IDENTIFIER ;
type        = basetype | arraytype | pointertype | structtype ;

statement   = (expression | assignment | vardecl | conditional) "." ;
builtin     = ("print") "(" expression ")" ;
vardecl     = "let" idargs "=" arguments ;
assignment  = arguments "=" arguments ;
conditional = "if" expression "do" statement*
              ( "end" | "else" (statement* "end" | conditional) ) ;
loop        = "loop" statement* "end" ;
while       = "while" expression "do" statement* "end" ;
forin       = "for" expression "in" expression "do" statement* "end" ;
for         = ; # TODO: Implement this or remove it; still not sure which to do

# Note that "undefined", though allowed anywhere an expression is in the syntax,
# should produce an error when not used in variable declarations
expression = logic | "undefined" ;
logic      = equality ( ("and" | "or")                  equality )*  ;
equality   = compare  ( ("==" | "!=")                   compare  )*  ;
compare    = bitwise  ( (">" | ">=" | "<" | "<=")       bitwise  )*  ;
bitwise    = term     ( ("&" | "|" | "^" | "<<" | ">>") term     )*  ;
term       = factor   ( ("+" | "-")                     factor   )*  ;
factor     = unary    ( ("*" | "/")                     unary    )*  ;
unary      =            ("~" | "!" | "not" | "-")       unary | call ;
call       = primary "(" arguments? ")" ;
primary    = "(" expression ")" | NUMBER | STRING | IDENTIFIER
            | "true" | "false" ;

# Not sure how to represent it, but the last idarg HAS to have type annotation
idargs    = idarg ( "," idarg )* ;
idarg     = IDENTIFIER (":" "mut"? type)? ;
arguments = expression ( "," expression )* ;
