# Grammar
# A grammar specification of the TriniC language using Extended Backus-Naur Form

program = declaration* EOF ;

declaration = structdecl | uniondecl | enumdecl | sumdecl
            | intrfcdecl | funcdecl  | vardecl  ;
structdecl  = structtype genericlist? idargs      "end" ;
uniondecl   = uniontype  genericlist? idargs      "end" ;
enumdecl    = enumtype   genericlist? assignargs  "end" ;
sumdecl     = sumtype    genericlist? sumargs     "end" ;
intrfcdecl  = intrfctype genericlist? function*   "end" ;
funcdecl    = "function" function "do" statement* "end" ;
function    = IDENTIFIER "(" (idargs | "void") ")" "->" ( type | IDENTIFIER )
              ("where" exprargs)? ("for" identifiers)? ;

basetype    = "int8"   | "int16"   | "int32"   | "int64"   | "isize"
            | "uint8"  | "uint16"  | "uint32"  | "uint64"  | "usize"
            | "float8" | "float16" | "float32" | "float64" | "fsize"
            | "byte"   | "char"    | "void"    | "bool" ;
arraytype   = "[" expression? "]" type ;
pointertype = "*" type ;
structtype  = "struct"    IDENTIFIER genericlist? ;
uniontype   = "union"     IDENTIFIER genericlist? ;
enumtype    = "enum"      IDENTIFIER genericlist? ;
sumtype     = "sum"       IDENTIFIER genericlist? ;
intrfctype  = "interface" IDENTIFIER genericlist? ;
type        = basetype | arraytype | pointertype | structtype | uniontype
            | enumtype | sumtype   | intrfctype  ;

statement   = (expression | assignment | vardecl | conditional) "." ;
builtin     = ("print") "(" expression ")" ;
vardecl     = "let" idargs "=" exprargs ;
assignment  = exprargs "=" exprargs ;
conditional = "if" expression "do" statement*
              ( "end" | "else" (statement* "end" | conditional) ) ;
loop        = "loop" statement* "end" ;
while       = "while" expression "do" statement* "end" ;
forin       = "for" expression "in" expression "do" statement* "end" ;

# Note that "undefined", though allowed anywhere an expression is in the syntax,
# should produce an error when not used in variable declarations
expression = logic | "undefined" ;
logic      = equality ( ("and" | "or")                  equality )*  ;
equality   = compare  ( ("==" | "!=")                   compare  )*  ;
compare    = bitwise  ( (">" | ">=" | "<" | "<=")       bitwise  )*  ;
bitwise    = term     ( ("&" | "|" | "^" | "<<" | ">>") term     )*  ;
term       = factor   ( ("+" | "-")                     factor   )*  ;
factor     = unary    ( ("*" | "/")                     unary    )*  ;
unary      =            ("~" | "!" | "not" | "-")       unary | call ;
call       = primary ("(" arguments? ")" | ("." | "->") IDENTIFIER)  ;
primary    = "(" expression ")" | NUMBER | STRING | IDENTIFIER
            | "true" | "false" | "[" expression "]" expression;

genericlist = "(" identifiers* ")" ;
identifiers = IDENTIFIER ( "," IDENTIFIER )* ;

sumargs = sumarg ( "," sumarg )* ;
sumarg  = IDENTIFIER ("(" sumlist ")")? ;
sumlist = (IDENTIFIER | type) ( "," (IDENTIFIER | type))* ;

# Not sure how to represent it, but the last idarg HAS to have type annotation
idargs      = idarg ( "," idarg )* ;
idarg       = IDENTIFIER (":" "mut"? type)? ;
exprargs    = expression ( "," expression )* ;
assignargs  = assignarg ( "," assignarg)* ;
# MUST evaluate to an integer using only constant values
assignarg   = IDENTIFIER ("=" expression)? ;
