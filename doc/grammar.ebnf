# Grammar
# A grammar specification of the TriniC language using Extended Backus-Naur Form

program = vardecl | function ;

function = "function" IDENTIFIER "(" (idargs | "void") ")" "->" type
           statement* "end" ;

basetype    =  "int8"   | "int16"   | "int32"   | "int64"   | "isize"
             | "uint8"  | "uint16"  | "uint32"  | "uint64"  | "usize"
             | "float8" | "float16" | "float32" | "float64" | "fsize"
             | "bool" ;
arraytype   = type "[" expression "]" ;
pointertype = type "*" ;
structtype  = "struct" IDENTIFIER (type IDENTIFIER ".")* "end" ;
type        = basetype | arraytype | pointertype | structtype ;

# TODO: Functions, types and anything that uses them

statement   = (expression | assignment | vardecl | conditional) "." ;
builtin     = ("print") "(" expression ")" ;
vardecl     = "let" idargs "=" arguments ;
assignment  = arguments "=" arguments ;
conditional = "if" expression "do" statement*
              ( "end" | "else" (statement* "end" | conditional) ) ;
loop        = "loop" statement* "end" ;
while       = "while" expression "do" statement* "end" ;
forin       = "for" expression "in" expression "do" statement* "end" ;
for         = ; # TODO

# Note that "undefined", though allowed anywhere an expression is in the syntax,
# should produce an error when not used in variable declarations
expression = logic | "undefined" ;
logic      = equality ( ("and" | "or")                  equality )*  ;
equality   = compare  ( ("==" | "!=")                   compare  )*  ;
compare    = bitwise  ( (">" | ">=" | "<" | "<=")       bitwise  )*  ;
bitwise    = term     ( ("&" | "|" | "^" | "<<" | ">>") term     )*  ;
term       = factor   ( ("+" | "-")                     factor   )*  ;
factor     = unary    ( ("*" | "/")                     unary    )*  ;
unary      =            ("~" | "!" | "not" | "-")       unary | call ;
call       = primary "(" arguments? ")" ;
primary    = "(" expression ")" | NUMBER | STRING | IDENTIFIER
            | "true" | "false" ;

# Not sure how to represent it, but the last idarg HAS to have type annotation
idargs    = idarg ( "," idarg )* ;
idarg     = IDENTIFIER (":" "mut"? type)? ;
arguments = expression ( "," expression )* ;
